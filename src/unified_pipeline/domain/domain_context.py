"""
Domain Context - Auto-detected Domain Information

도메인 컨텍스트 자동 탐지 시스템
- LLM 기반 도메인 분류
- 산업 도메인, 비즈니스 단계, 부서 자동 탐지
- 도메인별 권장 워크플로우 및 대시보드
- Phase 2/3에서 사용할 인사이트 패턴 자동 생성

Based on: _legacy/phase1/domain_detector.py
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
import json
import logging

logger = logging.getLogger(__name__)


class IndustryDomain(str, Enum):
    """Industry domain classification"""
    BEAUTY_COSMETICS = "beauty_cosmetics"
    RETAIL = "retail"
    FASHION = "fashion"
    FOOD_BEVERAGE = "food_beverage"
    MANUFACTURING = "manufacturing"
    HEALTHCARE = "healthcare"
    FINANCE = "finance"
    LOGISTICS = "logistics"
    ENERGY = "energy"
    TELECOM = "telecom"
    HOSPITALITY = "hospitality"
    EDUCATION = "education"
    MEDIA_ENTERTAINMENT = "media_entertainment"
    TECHNOLOGY = "technology"
    GENERAL = "general"


class BusinessStage(str, Enum):
    """Business process stage"""
    PRODUCTION = "production"
    SALES = "sales"
    MARKETING = "marketing"
    OPERATIONS = "operations"
    QUALITY = "quality"
    MAINTENANCE = "maintenance"
    FINANCE = "finance"
    HR = "hr"
    CUSTOMER_SERVICE = "customer_service"
    SUPPLY_CHAIN = "supply_chain"


class DataType(str, Enum):
    """Type of data"""
    OPERATIONAL = "operational"
    TRANSACTIONAL = "transactional"
    ANALYTICAL = "analytical"
    MASTER_DATA = "master_data"
    REFERENCE_DATA = "reference_data"


@dataclass
class InsightPattern:
    """Required insight pattern for Phase 2"""
    pattern_id: str
    name: str
    description: str
    source_tables: List[str] = field(default_factory=list)
    join_columns: Dict[str, str] = field(default_factory=dict)
    expected_kpis: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class DomainContext:
    """
    Detected domain context for a scenario

    This object is auto-generated by DomainDetector and used throughout
    Phase 1-3 for domain-specific processing.
    """

    # Industry classification
    industry: str = "general"  # IndustryDomain value
    industry_confidence: float = 0.5
    industry_evidence: List[str] = field(default_factory=list)

    # Business context
    business_stage: str = "operations"  # BusinessStage value
    department: str = "general"

    # Data characteristics
    data_type: str = "operational"  # DataType value
    temporal_granularity: str = "daily"  # real_time, hourly, daily, weekly, monthly, yearly

    # Entities and concepts (auto-detected)
    key_entities: List[str] = field(default_factory=list)
    key_metrics: List[str] = field(default_factory=list)

    # Workflow templates (domain-specific)
    recommended_workflows: List[str] = field(default_factory=list)
    recommended_dashboards: List[str] = field(default_factory=list)

    # Insight patterns for Phase 2 (dynamic)
    required_insight_patterns: List[InsightPattern] = field(default_factory=list)

    # Domain-specific KPI definitions
    kpi_definitions: Dict[str, Dict[str, Any]] = field(default_factory=dict)

    # Escalation paths (for governance)
    escalation_paths: Dict[str, List[str]] = field(default_factory=dict)

    # Metadata
    detection_timestamp: str = field(default_factory=lambda: datetime.now().isoformat())
    detection_evidence: Dict[str, Any] = field(default_factory=dict)
    is_auto_detected: bool = False

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        result = asdict(self)
        # Convert InsightPattern objects
        result["required_insight_patterns"] = [
            p.to_dict() if isinstance(p, InsightPattern) else p
            for p in self.required_insight_patterns
        ]
        return result

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "DomainContext":
        """Create from dictionary"""
        # Convert insight patterns
        patterns = data.get("required_insight_patterns", [])
        data["required_insight_patterns"] = [
            InsightPattern(**p) if isinstance(p, dict) else p
            for p in patterns
        ]
        return cls(**data)

    def get_workflow_config(self, workflow_type: str) -> Dict[str, Any]:
        """Get configuration for a specific workflow type"""
        workflow_configs = {
            # Beauty/Cosmetics workflows
            "customer_segmentation": {
                "required_fields": ["customer_id", "skin_type", "purchase_history"],
                "kpi_metrics": ["segment_size", "conversion_rate", "ltv"],
                "update_frequency": "weekly"
            },
            "personalized_recommendation": {
                "required_fields": ["customer_id", "skin_profile", "product_sku"],
                "kpi_metrics": ["recommendation_accuracy", "click_rate", "conversion"],
                "update_frequency": "real_time"
            },
            # Manufacturing workflows
            "preventive_maintenance": {
                "required_fields": ["equipment_id", "maintenance_type", "priority", "due_date"],
                "kpi_metrics": ["mttr", "mtbf", "planned_vs_unplanned"],
                "escalation_thresholds": {"critical": 24, "high": 72, "medium": 168}
            },
            "quality_control": {
                "required_fields": ["lot_id", "defect_type", "severity", "containment_status"],
                "kpi_metrics": ["defect_rate", "first_pass_yield", "scrap_rate"],
                "escalation_thresholds": {"critical": 4, "high": 24, "medium": 72}
            },
            # Healthcare workflows
            "patient_care_coordination": {
                "required_fields": ["patient_id", "provider_id", "care_plan"],
                "kpi_metrics": ["readmission_rate", "care_gap_closure", "patient_satisfaction"],
                "compliance": ["HIPAA"]
            },
            # General workflows
            "general_monitoring": {
                "required_fields": ["entity_id", "status", "timestamp"],
                "kpi_metrics": ["throughput", "utilization", "availability"],
                "update_frequency": "daily"
            },
            "demand_forecasting": {
                "required_fields": ["sku", "date", "quantity", "location"],
                "kpi_metrics": ["forecast_accuracy", "bias", "inventory_turns"],
                "update_frequency": "weekly"
            },
            "inventory_optimization": {
                "required_fields": ["sku", "location", "quantity", "reorder_point"],
                "kpi_metrics": ["stock_turnover", "fill_rate", "carrying_cost"],
                "update_frequency": "daily"
            },
            "performance_tracking": {
                "required_fields": ["employee_id", "metric_type", "value", "period"],
                "kpi_metrics": ["goal_attainment", "productivity_index"],
                "update_frequency": "weekly"
            },
            "loyalty_program_analysis": {
                "required_fields": ["customer_id", "loyalty_tier", "points", "transactions"],
                "kpi_metrics": ["tier_progression", "redemption_rate", "engagement_score"],
                "update_frequency": "monthly"
            },
        }
        return workflow_configs.get(workflow_type, workflow_configs["general_monitoring"])

    def get_dashboard_config(self, dashboard_type: str) -> Dict[str, Any]:
        """Get configuration for a specific dashboard type"""
        dashboard_configs = {
            "kpi_dashboard": {
                "widgets": [
                    {"type": "kpi-card", "position": {"x": 0, "y": 0, "w": 2, "h": 2}},
                    {"type": "kpi-card", "position": {"x": 2, "y": 0, "w": 2, "h": 2}},
                    {"type": "kpi-card", "position": {"x": 4, "y": 0, "w": 2, "h": 2}},
                    {"type": "table", "position": {"x": 0, "y": 2, "w": 6, "h": 4}}
                ],
                "update_frequency": "5_minutes"
            },
            "customer_360": {
                "widgets": [
                    {"type": "profile-card", "position": {"x": 0, "y": 0, "w": 2, "h": 4}},
                    {"type": "timeline", "position": {"x": 2, "y": 0, "w": 4, "h": 2}},
                    {"type": "recommendation-list", "position": {"x": 2, "y": 2, "w": 2, "h": 2}},
                    {"type": "segment-badge", "position": {"x": 4, "y": 2, "w": 2, "h": 2}}
                ],
                "update_frequency": "real_time"
            },
            "timeline_view": {
                "widgets": [
                    {"type": "timeline", "position": {"x": 0, "y": 0, "w": 6, "h": 4}},
                    {"type": "table", "position": {"x": 0, "y": 4, "w": 6, "h": 2}}
                ],
                "update_frequency": "1_minute"
            },
            "store_performance": {
                "widgets": [
                    {"type": "map", "position": {"x": 0, "y": 0, "w": 4, "h": 4}},
                    {"type": "ranking-list", "position": {"x": 4, "y": 0, "w": 2, "h": 4}},
                    {"type": "chart", "position": {"x": 0, "y": 4, "w": 6, "h": 2}}
                ],
                "update_frequency": "hourly"
            },
            "workflow_queue": {
                "widgets": [
                    {"type": "task-list", "position": {"x": 0, "y": 0, "w": 3, "h": 6}},
                    {"type": "metrics-panel", "position": {"x": 3, "y": 0, "w": 3, "h": 3}},
                    {"type": "alert-list", "position": {"x": 3, "y": 3, "w": 3, "h": 3}}
                ],
                "update_frequency": "real_time"
            },
            "chat_assistant": {
                "widgets": [
                    {"type": "chat-interface", "position": {"x": 0, "y": 0, "w": 4, "h": 6}},
                    {"type": "context-panel", "position": {"x": 4, "y": 0, "w": 2, "h": 6}}
                ],
                "update_frequency": "real_time"
            },
            "operations_room": {
                "widgets": [
                    {"type": "kpi-card", "position": {"x": 0, "y": 0, "w": 3, "h": 2}},
                    {"type": "alarm-list", "position": {"x": 3, "y": 0, "w": 3, "h": 4}},
                    {"type": "workflow-queue", "position": {"x": 0, "y": 2, "w": 3, "h": 4}},
                    {"type": "timeline", "position": {"x": 0, "y": 6, "w": 6, "h": 3}}
                ],
                "update_frequency": "real_time"
            },
        }
        return dashboard_configs.get(dashboard_type, dashboard_configs["kpi_dashboard"])

    def get_escalation_path(self, severity: str) -> List[str]:
        """Get escalation path for given severity"""
        # Default paths by industry
        default_paths = {
            "beauty_cosmetics": {
                "critical": ["MarketingDirector", "CMO", "CEO"],
                "high": ["CampaignManager", "MarketingDirector"],
                "medium": ["AnalyticsLead", "CampaignManager"],
                "low": ["AnalyticsLead"]
            },
            "manufacturing": {
                "critical": ["PlantManager", "VP_Manufacturing", "COO"],
                "high": ["ProductionSupervisor", "PlantManager"],
                "medium": ["ShiftLead", "ProductionSupervisor"],
                "low": ["ShiftLead"]
            },
            "healthcare": {
                "critical": ["ChiefMedicalOfficer", "HospitalAdministrator", "CEO"],
                "high": ["DepartmentHead", "ChiefMedicalOfficer"],
                "medium": ["NurseManager", "DepartmentHead"],
                "low": ["NurseManager"]
            },
            "general": {
                "critical": ["Director", "VP", "CEO"],
                "high": ["Manager", "Director"],
                "medium": ["TeamLead", "Manager"],
                "low": ["TeamLead"]
            }
        }

        # Use custom escalation if defined
        if self.escalation_paths:
            return self.escalation_paths.get(severity.lower(), ["TeamLead"])

        # Use industry default
        industry_paths = default_paths.get(self.industry, default_paths["general"])
        return industry_paths.get(severity.lower(), ["TeamLead"])

    def get_kpi_definition(self, kpi_name: str) -> Dict[str, Any]:
        """Get KPI definition"""
        if kpi_name in self.kpi_definitions:
            return self.kpi_definitions[kpi_name]

        # Default KPI definitions by industry
        default_kpis = {
            "beauty_cosmetics": {
                "conversion_rate": {"unit": "%", "target": 15.0, "threshold_low": 10.0},
                "customer_ltv": {"unit": "currency", "target": 500.0, "threshold_low": 200.0},
                "basket_size": {"unit": "currency", "target": 80.0, "threshold_low": 50.0},
                "repeat_purchase_rate": {"unit": "%", "target": 40.0, "threshold_low": 25.0},
                "nps_score": {"unit": "score", "target": 50.0, "threshold_low": 30.0},
            },
            "manufacturing": {
                "oee": {"unit": "%", "target": 85.0, "threshold_low": 70.0},
                "defect_rate": {"unit": "%", "target": 1.0, "threshold_high": 3.0},
                "throughput": {"unit": "units/hour", "target": 100.0, "threshold_low": 80.0},
                "downtime_hours": {"unit": "hours", "target": 0.0, "threshold_high": 4.0},
            },
            "healthcare": {
                "patient_satisfaction": {"unit": "%", "target": 90.0, "threshold_low": 80.0},
                "readmission_rate": {"unit": "%", "target": 5.0, "threshold_high": 10.0},
                "avg_wait_time": {"unit": "minutes", "target": 15.0, "threshold_high": 30.0},
            },
        }

        industry_kpis = default_kpis.get(self.industry, {})
        return industry_kpis.get(kpi_name, {"unit": "value", "target": 0.0})

    def get_all_kpi_definitions(self) -> Dict[str, Dict[str, Any]]:
        """Get all KPI definitions for this industry"""
        industry_kpis = {
            "beauty_cosmetics": {
                "conversion_rate": {"unit": "%", "target": 15.0, "threshold_low": 10.0, "description": "구매 전환율"},
                "customer_ltv": {"unit": "currency", "target": 500.0, "threshold_low": 200.0, "description": "고객 생애가치"},
                "basket_size": {"unit": "currency", "target": 80.0, "threshold_low": 50.0, "description": "평균 장바구니 금액"},
                "repeat_purchase_rate": {"unit": "%", "target": 40.0, "threshold_low": 25.0, "description": "재구매율"},
                "nps_score": {"unit": "score", "target": 50.0, "threshold_low": 30.0, "description": "순추천지수"},
            },
            "manufacturing": {
                "oee": {"unit": "%", "target": 85.0, "threshold_low": 70.0, "description": "설비종합효율"},
                "defect_rate": {"unit": "%", "target": 1.0, "threshold_high": 3.0, "description": "불량률"},
                "throughput": {"unit": "units/hour", "target": 100.0, "threshold_low": 80.0, "description": "처리량"},
                "downtime_hours": {"unit": "hours", "target": 0.0, "threshold_high": 4.0, "description": "가동중단시간"},
                "mttr": {"unit": "hours", "target": 2.0, "threshold_high": 4.0, "description": "평균수리시간"},
                "mtbf": {"unit": "hours", "target": 500.0, "threshold_low": 200.0, "description": "평균고장간격"},
            },
            "healthcare": {
                "patient_satisfaction": {"unit": "%", "target": 90.0, "threshold_low": 80.0, "description": "환자 만족도"},
                "readmission_rate": {"unit": "%", "target": 5.0, "threshold_high": 10.0, "description": "재입원율"},
                "avg_wait_time": {"unit": "minutes", "target": 15.0, "threshold_high": 30.0, "description": "평균 대기시간"},
                "bed_occupancy_rate": {"unit": "%", "target": 80.0, "threshold_high": 95.0, "description": "병상 가동률"},
            },
            "retail": {
                "conversion_rate": {"unit": "%", "target": 12.0, "threshold_low": 8.0, "description": "구매 전환율"},
                "basket_size": {"unit": "currency", "target": 50.0, "threshold_low": 30.0, "description": "평균 장바구니 금액"},
                "sales_per_sqft": {"unit": "currency", "target": 500.0, "threshold_low": 300.0, "description": "평당 매출"},
                "inventory_turnover": {"unit": "ratio", "target": 8.0, "threshold_low": 4.0, "description": "재고회전율"},
            },
        }
        return industry_kpis.get(self.industry, {})

    def estimate_kpi_impact(self, action_type: str, confidence: float = 0.7) -> Dict[str, Any]:
        """
        Estimate KPI impact for an action (based on legacy domain_plugins.py)

        Args:
            action_type: Type of action being taken
            confidence: Confidence score of the insight (0-1)

        Returns:
            Dictionary with estimated KPI changes
        """
        base = confidence * 10

        industry_impacts = {
            "beauty_cosmetics": {
                "conversion_rate_lift_pct": base,
                "ltv_increase": base * 20,
                "basket_size_increase": base * 2,
                "repeat_rate_improvement": base * 0.3,
                "estimated_revenue_impact": base * 10000,
                "confidence_interval": [base * 0.7, base * 1.3],
            },
            "manufacturing": {
                "throughput_improvement_pct": base,
                "quality_rate_delta": base * 0.5,
                "downtime_reduction_hours": base * 2,
                "estimated_cost_savings": base * 5000,
                "oee_improvement": base * 0.5,
                "confidence_interval": [base * 0.7, base * 1.3],
            },
            "healthcare": {
                "patient_satisfaction_lift": base * 0.5,
                "readmission_reduction_pct": base * 0.3,
                "wait_time_reduction_min": base * 2,
                "estimated_cost_avoidance": base * 3000,
                "confidence_interval": [base * 0.7, base * 1.3],
            },
            "retail": {
                "conversion_rate_lift_pct": base * 0.8,
                "basket_size_increase": base * 1.5,
                "inventory_optimization_pct": base * 0.5,
                "estimated_revenue_impact": base * 5000,
                "confidence_interval": [base * 0.7, base * 1.3],
            },
        }

        return industry_impacts.get(self.industry, {
            "estimated_improvement_pct": base,
            "confidence_interval": [base * 0.7, base * 1.3],
        })

    def get_review_period_days(self, confidence: float) -> int:
        """
        Get recommended review period based on confidence (from legacy domain_plugins.py)

        Args:
            confidence: Confidence score (0-1)

        Returns:
            Number of days until next review
        """
        industry_periods = {
            "beauty_cosmetics": {
                0.9: 14,  # High confidence = 2 weeks
                0.8: 10,
                0.7: 7,
                0.0: 5,   # Low confidence = 5 days
            },
            "manufacturing": {
                0.9: 14,
                0.7: 7,
                0.0: 3,
            },
            "healthcare": {
                0.9: 30,  # Healthcare needs longer review cycles
                0.7: 21,
                0.0: 14,
            },
            "retail": {
                0.9: 7,   # Retail is fast-paced
                0.7: 5,
                0.0: 3,
            },
        }

        periods = industry_periods.get(self.industry, {0.9: 14, 0.7: 7, 0.0: 3})

        for threshold, days in sorted(periods.items(), reverse=True):
            if confidence >= threshold:
                return days

        return 7  # Default: 1 week


# Default domain context (fallback)
DEFAULT_DOMAIN_CONTEXT = DomainContext(
    industry="general",
    industry_confidence=0.5,
    business_stage="operations",
    department="general",
    data_type="operational",
    temporal_granularity="daily",
    key_entities=[],
    key_metrics=[],
    recommended_workflows=["general_monitoring"],
    recommended_dashboards=["kpi_dashboard"],
    is_auto_detected=False,
)
