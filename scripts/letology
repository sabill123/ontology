#!/usr/bin/env python3
"""
Letology CLI - Command Line Interface for Ontology OS

Usage:
    ./letology run-phase --phase 1 --scenario manufacturing_precision_ai
    ./letology run-all --scenario manufacturing_precision_ai
    ./letology status --scenario manufacturing_precision_ai
"""

import sys
import os
import argparse
import json
import requests
from pathlib import Path
from datetime import datetime
from typing import Optional

# Add project root to path
PROJECT_ROOT = Path(__file__).parent.parent
sys.path.insert(0, str(PROJECT_ROOT))

API_BASE = os.getenv("LETOLOGY_API_URL", "http://localhost:4200")


class LetologyCLI:
    def __init__(self, api_base: str = API_BASE):
        self.api_base = api_base
    
    def run_phase(self, phase: int, scenario: str, wait: bool = True):
        """Run a single phase"""
        print(f"\n{'='*60}")
        print(f"üöÄ Running Phase {phase} for scenario: {scenario}")
        print(f"{'='*60}\n")
        
        # Trigger phase
        endpoint = f"{self.api_base}/api/phase{phase}/run"
        try:
            response = requests.post(endpoint, timeout=5)
            response.raise_for_status()
            result = response.json()
            print(f"‚úÖ {result.get('message', 'Phase started')}")
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error starting Phase {phase}: {e}")
            return False
        
        if not wait:
            print("\nüîÑ Phase running in background. Use 'letology status' to check progress.")
            return True
        
        # Wait and check results
        print("\n‚è≥ Waiting for Phase to complete...")
        import time
        time.sleep(10)  # Wait for processing
        
        # Check output file
        output_file = PROJECT_ROOT / f"data/scenarios/{scenario}/phase{phase}__phase{phase}_output.json"
        if output_file.exists():
            with open(output_file) as f:
                data = json.load(f)
            self._print_phase_summary(phase, data)
            return True
        else:
            print(f"‚ö†Ô∏è  Output file not found: {output_file}")
            return False
    
    def run_all(self, scenario: str):
        """Run all phases sequentially"""
        print(f"\n{'='*60}")
        print(f"üè≠ Running FULL PIPELINE for scenario: {scenario}")
        print(f"{'='*60}\n")
        
        phases_success = []
        for phase in [1, 2, 3]:
            success = self.run_phase(phase, scenario, wait=True)
            phases_success.append(success)
            if not success:
                print(f"\n‚ùå Pipeline stopped at Phase {phase}")
                break
            print(f"\n{'‚îÄ'*60}\n")
        
        # Final summary
        print(f"\n{'='*60}")
        print("üìä PIPELINE SUMMARY")
        print(f"{'='*60}")
        for i, success in enumerate(phases_success, 1):
            status = "‚úÖ SUCCESS" if success else "‚ùå FAILED"
            print(f"  Phase {i}: {status}")
        
        if all(phases_success):
            print(f"\nüéâ Full pipeline completed successfully!")
            self._print_evidence_chain(scenario)
        else:
            print(f"\n‚ö†Ô∏è  Pipeline completed with errors")
    
    def status(self, scenario: str):
        """Check scenario status"""
        print(f"\n{'='*60}")
        print(f"üìä Status for scenario: {scenario}")
        print(f"{'='*60}\n")
        
        try:
            response = requests.get(f"{self.api_base}/api/status", timeout=5)
            response.raise_for_status()
            status_data = response.json()
            
            print(f"Status: {status_data.get('status', 'unknown')}")
            print(f"Active Scenario: {status_data.get('active_scenario', 'N/A')}")
            print(f"Sources: {status_data.get('source_count', 0)}")
            print(f"Concepts: {status_data.get('concept_count', 0)} confirmed, {status_data.get('pending_concepts', 0)} pending")
            print(f"Insights: {status_data.get('insight_count', 0)}")
            print(f"Actions: {status_data.get('action_count', 0)}")
            
        except requests.exceptions.RequestException as e:
            print(f"‚ùå Error fetching status: {e}")
            return
        
        # Check output files
        print(f"\nüìÅ Output Files:")
        for phase in [1, 2, 3]:
            output_file = PROJECT_ROOT / f"data/scenarios/{scenario}/phase{phase}__phase{phase}_output.json"
            if output_file.exists():
                size_kb = output_file.stat().st_size / 1024
                mod_time = datetime.fromtimestamp(output_file.stat().st_mtime)
                print(f"  ‚úÖ Phase {phase}: {size_kb:.1f}KB (modified: {mod_time.strftime('%Y-%m-%d %H:%M')})")
            else:
                print(f"  ‚ùå Phase {phase}: Not found")
    
    def _print_phase_summary(self, phase: int, data: dict):
        """Print phase-specific summary"""
        print(f"\nüìã Phase {phase} Results:")
        
        if phase == 1:
            summary = data.get('summary', {})
            print(f"  Total Silos: {summary.get('total_silos', 0)}")
            print(f"  Total Mappings: {summary.get('total_mappings', 0)}")
            print(f"  Topology Score: {summary.get('topology_score', 0):.3f}")
            print(f"  Canonical Objects: {len(data.get('canonical_objects', []))}")
            print(f"  Cross-Silo Links: {len(data.get('cross_silo_links', []))}")
        
        elif phase == 2:
            summary = data.get('summary', {})
            scores = data.get('validation_scores', {})
            print(f"  Total Insights: {summary.get('total_insights', 0)}")
            print(f"  Average Confidence: {summary.get('avg_confidence', 0):.3f}")
            print(f"  Topology Fidelity: {scores.get('topology_fidelity', 0):.3f}")
            print(f"  Overall Score: {scores.get('overall_score', 0):.3f}")
            print(f"  Phase 1 Mappings Used: {len(data.get('phase1_mappings_used', []))}")
        
        elif phase == 3:
            summary = data.get('summary', {})
            evidence = data.get('evidence_chain_summary', {})
            print(f"  Total Actions: {summary.get('total_actions', 0)}")
            print(f"  Approved: {summary.get('approved', 0)} ({summary.get('approval_rate', 0)*100:.1f}%)")
            print(f"  Monitor: {summary.get('monitor', 0)}")
            print(f"  Actions with Evidence: {evidence.get('actions_with_evidence', 0)}")
    
    def _print_evidence_chain(self, scenario: str):
        """Print evidence chain summary"""
        print(f"\n‚õìÔ∏è  EVIDENCE CHAIN:")
        
        try:
            # Load all phase outputs
            p1_file = PROJECT_ROOT / f"data/scenarios/{scenario}/phase1__phase1_output.json"
            p2_file = PROJECT_ROOT / f"data/scenarios/{scenario}/phase2__phase2_output.json"
            p3_file = PROJECT_ROOT / f"data/scenarios/{scenario}/phase3__phase3_output.json"
            
            if all(f.exists() for f in [p1_file, p2_file, p3_file]):
                with open(p1_file) as f:
                    p1 = json.load(f)
                with open(p2_file) as f:
                    p2 = json.load(f)
                with open(p3_file) as f:
                    p3 = json.load(f)
                
                print(f"  Phase 1 ‚Üí Phase 2:")
                print(f"    {len(p1.get('mappings', []))} mappings ‚Üí {len(p2.get('phase1_mappings_used', []))} used")
                
                print(f"  Phase 2 ‚Üí Phase 3:")
                print(f"    {len(p2.get('insights', []))} insights ‚Üí {p3.get('evidence_chain_summary', {}).get('actions_with_evidence', 0)} actions with evidence")
                
                print(f"\n  ‚úÖ Evidence Chain Complete!")
            else:
                print(f"  ‚ö†Ô∏è  Some phase outputs missing")
                
        except Exception as e:
            print(f"  ‚ùå Error reading evidence chain: {e}")


def main():
    parser = argparse.ArgumentParser(
        description="Letology CLI - Ontology OS Command Line Interface",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Run single phase
  ./letology run-phase --phase 1 --scenario manufacturing_precision_ai
  
  # Run full pipeline
  ./letology run-all --scenario manufacturing_precision_ai
  
  # Check status
  ./letology status --scenario manufacturing_precision_ai
        """
    )
    
    parser.add_argument(
        "command",
        choices=["run-phase", "run-all", "status"],
        help="Command to execute"
    )
    
    parser.add_argument(
        "--scenario",
        required=True,
        help="Scenario name (e.g., manufacturing_precision_ai)"
    )
    
    parser.add_argument(
        "--phase",
        type=int,
        choices=[1, 2, 3],
        help="Phase number (required for run-phase)"
    )
    
    parser.add_argument(
        "--no-wait",
        action="store_true",
        help="Don't wait for phase completion"
    )
    
    parser.add_argument(
        "--api-url",
        default=API_BASE,
        help=f"API base URL (default: {API_BASE})"
    )
    
    args = parser.parse_args()
    
    # Validate arguments
    if args.command == "run-phase" and not args.phase:
        parser.error("--phase is required for run-phase command")
    
    # Execute command
    cli = LetologyCLI(api_base=args.api_url)
    
    try:
        if args.command == "run-phase":
            cli.run_phase(args.phase, args.scenario, wait=not args.no_wait)
        elif args.command == "run-all":
            cli.run_all(args.scenario)
        elif args.command == "status":
            cli.status(args.scenario)
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è  Interrupted by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
